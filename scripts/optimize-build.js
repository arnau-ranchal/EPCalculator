#!/usr/bin/env node\n\n// Build optimization script for university server deployment\nimport { execSync } from 'child_process'\nimport fs from 'fs'\nimport path from 'path'\nimport { gzipSync } from 'zlib'\n\nconst PUBLIC_DIR = 'public'\nconst DIST_DIR = 'dist'\n\nconsole.log('üîß Starting build optimization for university deployment...')\n\n// Step 1: Clean previous builds\nfunction cleanPreviousBuilds() {\n  console.log('üßπ Cleaning previous builds...')\n  try {\n    execSync(`rm -rf ${PUBLIC_DIR}/*`, { stdio: 'inherit' })\n    execSync(`rm -rf ${DIST_DIR}/*`, { stdio: 'inherit' })\n  } catch (error) {\n    console.warn('Warning: Could not clean previous builds')\n  }\n}\n\n// Step 2: Build WebAssembly\nfunction buildWebAssembly() {\n  console.log('‚ö° Building WebAssembly modules...')\n  try {\n    execSync('./scripts/build-wasm.sh', { stdio: 'inherit' })\n  } catch (error) {\n    console.warn('Warning: WebAssembly build failed, falling back to server computation')\n  }\n}\n\n// Step 3: Build frontend with Vite\nfunction buildFrontend() {\n  console.log('üèóÔ∏è Building optimized frontend...')\n  execSync('npm run build:frontend', { stdio: 'inherit' })\n}\n\n// Step 4: Build backend\nfunction buildBackend() {\n  console.log('üöÄ Building backend...')\n  execSync('npm run build:backend', { stdio: 'inherit' })\n}\n\n// Step 5: Optimize assets\nfunction optimizeAssets() {\n  console.log('üéØ Optimizing assets for university servers...')\n  \n  const publicPath = path.resolve(PUBLIC_DIR)\n  if (!fs.existsSync(publicPath)) {\n    console.warn('Public directory not found, skipping asset optimization')\n    return\n  }\n\n  // Find all JavaScript and CSS files\n  const files = fs.readdirSync(publicPath, { recursive: true })\n  let totalSavings = 0\n\n  files.forEach(file => {\n    const filePath = path.join(publicPath, file)\n    const stat = fs.statSync(filePath)\n\n    if (stat.isFile() && (file.endsWith('.js') || file.endsWith('.css'))) {\n      const originalSize = stat.size\n      \n      // Pre-compress files for nginx gzip_static\n      const content = fs.readFileSync(filePath)\n      const compressed = gzipSync(content, { level: 9 })\n      fs.writeFileSync(filePath + '.gz', compressed)\n      \n      const compressionRatio = ((originalSize - compressed.length) / originalSize * 100).toFixed(1)\n      console.log(`  üì¶ ${file}: ${formatBytes(originalSize)} ‚Üí ${formatBytes(compressed.length)} (${compressionRatio}% savings)`)\n      totalSavings += originalSize - compressed.length\n    }\n  })\n\n  console.log(`üíæ Total compression savings: ${formatBytes(totalSavings)}`)\n}\n\n// Step 6: Generate build report\nfunction generateBuildReport() {\n  console.log('üìä Generating build report...')\n  \n  const report = {\n    timestamp: new Date().toISOString(),\n    version: '2.0.0',\n    sizes: {},\n    optimizations: {\n      webassembly: fs.existsSync('public/wasm/epcalculator.wasm'),\n      compression: true,\n      minification: true,\n      treeshaking: true\n    }\n  }\n\n  // Calculate sizes\n  const calculateDirSize = (dir) => {\n    if (!fs.existsSync(dir)) return 0\n    let size = 0\n    const files = fs.readdirSync(dir, { recursive: true })\n    files.forEach(file => {\n      const filePath = path.join(dir, file)\n      const stat = fs.statSync(filePath)\n      if (stat.isFile()) size += stat.size\n    })\n    return size\n  }\n\n  report.sizes = {\n    frontend: formatBytes(calculateDirSize(PUBLIC_DIR)),\n    backend: formatBytes(calculateDirSize(DIST_DIR)),\n    webassembly: formatBytes(calculateDirSize('public/wasm') || 0)\n  }\n\n  fs.writeFileSync('build-report.json', JSON.stringify(report, null, 2))\n  console.log('üìÑ Build report saved to build-report.json')\n  \n  console.log('\\nüìã Build Summary:')\n  console.log(`  Frontend: ${report.sizes.frontend}`)\n  console.log(`  Backend: ${report.sizes.backend}`)\n  console.log(`  WebAssembly: ${report.sizes.webassembly}`)\n  console.log(`  WASM Available: ${report.optimizations.webassembly ? '‚úÖ' : '‚ùå'}`)\n}\n\n// Utility functions\nfunction formatBytes(bytes) {\n  if (bytes === 0) return '0 B'\n  const k = 1024\n  const sizes = ['B', 'KB', 'MB', 'GB']\n  const i = Math.floor(Math.log(bytes) / Math.log(k))\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i]\n}\n\n// Main execution\nasync function main() {\n  try {\n    cleanPreviousBuilds()\n    buildWebAssembly()\n    buildFrontend()\n    buildBackend()\n    optimizeAssets()\n    generateBuildReport()\n    \n    console.log('\\n‚úÖ Build optimization completed successfully!')\n    console.log('üö¢ Ready for university Kubernetes deployment')\n    \n  } catch (error) {\n    console.error('‚ùå Build optimization failed:', error.message)\n    process.exit(1)\n  }\n}\n\nmain()"