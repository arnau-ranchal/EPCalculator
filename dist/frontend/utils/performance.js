"use strict";
// Performance monitoring and optimization utilities\n\n// Performance metrics collection\ninterface PerformanceMetrics {\n  // Core Web Vitals\n  lcp?: number // Largest Contentful Paint\n  fid?: number // First Input Delay\n  cls?: number // Cumulative Layout Shift\n  \n  // Custom metrics\n  ttfb?: number // Time to First Byte\n  fcp?: number // First Contentful Paint\n  tti?: number // Time to Interactive\n  \n  // Application-specific metrics\n  wasmLoadTime?: number\n  firstComputationTime?: number\n  averageComputationTime?: number\n  cacheHitRate?: number\n  \n  // Resource usage\n  memoryUsage?: number\n  cpuUsage?: number\n  networkLatency?: number\n}\n\n// Global performance data\nlet performanceData: PerformanceMetrics = {}\nlet computationTimes: number[] = []\nlet cacheRequests = { hits: 0, misses: 0 }\n\n// Initialize performance monitoring\nexport function initializePerformanceMonitoring(): void {\n  console.log('ðŸ“Š Initializing performance monitoring...')\n  \n  // Measure Core Web Vitals\n  measureCoreWebVitals()\n  \n  // Monitor memory usage\n  monitorMemoryUsage()\n  \n  // Monitor network performance\n  monitorNetworkPerformance()\n  \n  // Set up periodic reporting\n  setupPerformanceReporting()\n  \n  console.log('âœ… Performance monitoring initialized')\n}\n\n// Core Web Vitals measurement\nfunction measureCoreWebVitals(): void {\n  // Largest Contentful Paint (LCP)\n  if ('PerformanceObserver' in window) {\n    try {\n      const lcpObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries()\n        const lastEntry = entries[entries.length - 1] as any\n        performanceData.lcp = lastEntry.startTime\n        console.log('ðŸ“ LCP:', performanceData.lcp)\n      })\n      lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] })\n    } catch (error) {\n      console.warn('LCP measurement not supported')\n    }\n\n    // First Input Delay (FID)\n    try {\n      const fidObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries()\n        entries.forEach((entry: any) => {\n          performanceData.fid = entry.processingStart - entry.startTime\n          console.log('ðŸ“ FID:', performanceData.fid)\n        })\n      })\n      fidObserver.observe({ entryTypes: ['first-input'] })\n    } catch (error) {\n      console.warn('FID measurement not supported')\n    }\n\n    // Cumulative Layout Shift (CLS)\n    try {\n      let clsScore = 0\n      const clsObserver = new PerformanceObserver((list) => {\n        const entries = list.getEntries()\n        entries.forEach((entry: any) => {\n          if (!entry.hadRecentInput) {\n            clsScore += entry.value\n          }\n        })\n        performanceData.cls = clsScore\n        console.log('ðŸ“ CLS:', performanceData.cls)\n      })\n      clsObserver.observe({ entryTypes: ['layout-shift'] })\n    } catch (error) {\n      console.warn('CLS measurement not supported')\n    }\n  }\n\n  // Fallback measurements using Performance API\n  if ('performance' in window && performance.timing) {\n    window.addEventListener('load', () => {\n      const timing = performance.timing\n      performanceData.ttfb = timing.responseStart - timing.navigationStart\n      performanceData.fcp = timing.loadEventEnd - timing.navigationStart\n      \n      console.log('ðŸ“ TTFB:', performanceData.ttfb)\n      console.log('ðŸ“ Page Load:', performanceData.fcp)\n    })\n  }\n}\n\n// Memory usage monitoring\nfunction monitorMemoryUsage(): void {\n  if ('memory' in performance) {\n    const updateMemoryUsage = () => {\n      const memory = (performance as any).memory\n      performanceData.memoryUsage = memory.usedJSHeapSize / 1024 / 1024 // MB\n      \n      // Warn if memory usage is high\n      if (performanceData.memoryUsage > 100) {\n        console.warn('âš ï¸ High memory usage:', performanceData.memoryUsage, 'MB')\n      }\n    }\n    \n    // Update every 30 seconds\n    setInterval(updateMemoryUsage, 30000)\n    updateMemoryUsage() // Initial measurement\n  }\n}\n\n// Network performance monitoring\nfunction monitorNetworkPerformance(): void {\n  if ('connection' in navigator) {\n    const connection = (navigator as any).connection\n    const updateNetworkInfo = () => {\n      console.log('ðŸŒ Network:', {\n        effectiveType: connection.effectiveType,\n        downlink: connection.downlink,\n        rtt: connection.rtt\n      })\n      performanceData.networkLatency = connection.rtt\n    }\n    \n    connection.addEventListener('change', updateNetworkInfo)\n    updateNetworkInfo()\n  }\n}\n\n// Track WebAssembly loading performance\nexport function trackWasmLoadTime(startTime: number, endTime: number): void {\n  performanceData.wasmLoadTime = endTime - startTime\n  console.log('âš¡ WebAssembly load time:', performanceData.wasmLoadTime, 'ms')\n}\n\n// Track computation performance\nexport function trackComputationTime(computationTime: number): void {\n  computationTimes.push(computationTime)\n  \n  // Keep only last 100 computations\n  if (computationTimes.length > 100) {\n    computationTimes = computationTimes.slice(-100)\n  }\n  \n  // Update average\n  performanceData.averageComputationTime = \n    computationTimes.reduce((a, b) => a + b, 0) / computationTimes.length\n  \n  // Track first computation time\n  if (!performanceData.firstComputationTime) {\n    performanceData.firstComputationTime = computationTime\n  }\n  \n  console.log('ðŸ§® Computation time:', computationTime, 'ms (avg:', performanceData.averageComputationTime, 'ms)')\n}\n\n// Track cache performance\nexport function trackCacheHit(): void {\n  cacheRequests.hits++\n  updateCacheHitRate()\n}\n\nexport function trackCacheMiss(): void {\n  cacheRequests.misses++\n  updateCacheHitRate()\n}\n\nfunction updateCacheHitRate(): void {\n  const total = cacheRequests.hits + cacheRequests.misses\n  performanceData.cacheHitRate = total > 0 ? (cacheRequests.hits / total) * 100 : 0\n  console.log('ðŸ’¾ Cache hit rate:', performanceData.cacheHitRate.toFixed(1), '%')\n}\n\n// Performance optimization recommendations\nexport function getPerformanceRecommendations(): string[] {\n  const recommendations: string[] = []\n  \n  if (performanceData.lcp && performanceData.lcp > 2500) {\n    recommendations.push('Consider optimizing Largest Contentful Paint (LCP) - current: ' + performanceData.lcp + 'ms')\n  }\n  \n  if (performanceData.fid && performanceData.fid > 100) {\n    recommendations.push('Consider optimizing First Input Delay (FID) - current: ' + performanceData.fid + 'ms')\n  }\n  \n  if (performanceData.cls && performanceData.cls > 0.1) {\n    recommendations.push('Consider reducing Cumulative Layout Shift (CLS) - current: ' + performanceData.cls)\n  }\n  \n  if (performanceData.memoryUsage && performanceData.memoryUsage > 150) {\n    recommendations.push('High memory usage detected - consider memory optimization')\n  }\n  \n  if (performanceData.cacheHitRate && performanceData.cacheHitRate < 50) {\n    recommendations.push('Low cache hit rate - consider caching optimization')\n  }\n  \n  if (performanceData.averageComputationTime && performanceData.averageComputationTime > 5000) {\n    recommendations.push('Slow computation times - consider WebAssembly optimization')\n  }\n  \n  return recommendations\n}\n\n// Resource loading optimization\nexport function preloadCriticalResources(): void {\n  const criticalResources = [\n    '/wasm/epcalculator.wasm',\n    '/wasm/epcalculator.js'\n  ]\n  \n  criticalResources.forEach(resource => {\n    const link = document.createElement('link')\n    link.rel = 'preload'\n    link.href = resource\n    \n    if (resource.endsWith('.wasm')) {\n      link.as = 'fetch'\n      link.crossOrigin = 'anonymous'\n    } else if (resource.endsWith('.js')) {\n      link.as = 'script'\n    }\n    \n    document.head.appendChild(link)\n  })\n}\n\n// Image optimization\nexport function optimizeImages(): void {\n  const images = document.querySelectorAll('img')\n  \n  images.forEach(img => {\n    // Add loading=\"lazy\" for off-screen images\n    if (!img.hasAttribute('loading')) {\n      img.loading = 'lazy'\n    }\n    \n    // Add decoding=\"async\" for better performance\n    if (!img.hasAttribute('decoding')) {\n      img.decoding = 'async'\n    }\n  })\n}\n\n// Bundle size analysis\nexport function analyzeBundleSize(): Promise<{ size: number; gzipped?: number }> {\n  return new Promise((resolve) => {\n    // Estimate bundle size based on script tags\n    const scripts = document.querySelectorAll('script[src]')\n    let totalSize = 0\n    let loadedScripts = 0\n    \n    if (scripts.length === 0) {\n      resolve({ size: 0 })\n      return\n    }\n    \n    scripts.forEach(script => {\n      fetch(script.src, { method: 'HEAD' })\n        .then(response => {\n          const contentLength = response.headers.get('content-length')\n          if (contentLength) {\n            totalSize += parseInt(contentLength)\n          }\n          loadedScripts++\n          \n          if (loadedScripts === scripts.length) {\n            resolve({ size: totalSize })\n          }\n        })\n        .catch(() => {\n          loadedScripts++\n          if (loadedScripts === scripts.length) {\n            resolve({ size: totalSize })\n          }\n        })\n    })\n  })\n}\n\n// Performance reporting\nfunction setupPerformanceReporting(): void {\n  // Send performance data to server every 5 minutes\n  setInterval(() => {\n    const report = generatePerformanceReport()\n    console.log('ðŸ“Š Performance Report:', report)\n    \n    // Could send to analytics endpoint\n    // fetch('/api/analytics/performance', {\n    //   method: 'POST',\n    //   headers: { 'Content-Type': 'application/json' },\n    //   body: JSON.stringify(report)\n    // })\n  }, 5 * 60 * 1000) // 5 minutes\n}\n\n// Generate comprehensive performance report\nexport function generatePerformanceReport(): {\n  timestamp: string\n  metrics: PerformanceMetrics\n  recommendations: string[]\n  userAgent: string\n  url: string\n  viewport: { width: number; height: number }\n  connection?: any\n} {\n  return {\n    timestamp: new Date().toISOString(),\n    metrics: { ...performanceData },\n    recommendations: getPerformanceRecommendations(),\n    userAgent: navigator.userAgent,\n    url: window.location.href,\n    viewport: {\n      width: window.innerWidth,\n      height: window.innerHeight\n    },\n    connection: (navigator as any).connection || undefined\n  }\n}\n\n// Performance debugging helpers\nexport function logPerformanceTimeline(): void {\n  if ('performance' in window && performance.getEntriesByType) {\n    const entries = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming\n    \n    console.table({\n      'DNS Lookup': entries.domainLookupEnd - entries.domainLookupStart,\n      'TCP Connection': entries.connectEnd - entries.connectStart,\n      'TLS Handshake': entries.connectEnd - entries.secureConnectionStart,\n      'Request': entries.responseStart - entries.requestStart,\n      'Response': entries.responseEnd - entries.responseStart,\n      'DOM Processing': entries.domContentLoadedEventStart - entries.responseEnd,\n      'Resource Loading': entries.loadEventStart - entries.domContentLoadedEventEnd,\n      'Total': entries.loadEventEnd - entries.navigationStart\n    })\n  }\n}\n\n// Get current performance data\nexport function getCurrentPerformanceData(): PerformanceMetrics {\n  return { ...performanceData }\n}\n\n// Reset performance tracking\nexport function resetPerformanceTracking(): void {\n  performanceData = {}\n  computationTimes = []\n  cacheRequests = { hits: 0, misses: 0 }\n  console.log('ðŸ”„ Performance tracking reset')\n}\n\n// University-specific optimizations\nexport function applyUniversityOptimizations(): void {\n  console.log('ðŸ« Applying university-specific optimizations...')\n  \n  // Reduce update frequency for slower networks\n  if (performanceData.networkLatency && performanceData.networkLatency > 200) {\n    console.log('ðŸ“¡ Slow network detected, reducing update frequency')\n    // Could adjust polling intervals, etc.\n  }\n  \n  // Optimize for lower memory on shared servers\n  if (performanceData.memoryUsage && performanceData.memoryUsage > 50) {\n    console.log('ðŸ’¾ Optimizing for limited memory')\n    // Could trigger garbage collection, clear caches, etc.\n  }\n  \n  // Preload resources during off-peak hours\n  const hour = new Date().getHours()\n  if (hour < 8 || hour > 22) {\n    console.log('ðŸŒ™ Off-peak hours, preloading resources')\n    preloadCriticalResources()\n  }\n}\n\n// Export for global access\nif (typeof window !== 'undefined') {\n  (window as any).EPCalculatorPerformance = {\n    report: generatePerformanceReport,\n    timeline: logPerformanceTimeline,\n    data: getCurrentPerformanceData,\n    reset: resetPerformanceTracking,\n    recommendations: getPerformanceRecommendations\n  }\n}"
