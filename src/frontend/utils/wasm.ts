import type { WasmModule, WasmComputationResult, ComputationParameters } from '../types'\n\n// WebAssembly module state\nlet wasmModule: WasmModule | null = null\nlet isLoading = false\nlet loadError: string | null = null\n\n// WebAssembly module loading\nexport async function initializeWasm(): Promise<void> {\n  if (wasmModule || isLoading) {\n    return\n  }\n\n  isLoading = true\n  loadError = null\n\n  try {\n    // Check if WebAssembly is supported\n    if (typeof WebAssembly === 'undefined') {\n      throw new Error('WebAssembly is not supported in this browser')\n    }\n\n    console.log('ðŸ”§ Loading WebAssembly module...')\n\n    // Dynamic import of the WebAssembly module\n    const EPCalculatorModule = await import('/wasm/epcalculator.js')\n    \n    // Initialize the module\n    const module = await EPCalculatorModule.default({\n      locateFile: (path: string) => {\n        if (path.endsWith('.wasm')) {\n          return '/wasm/' + path\n        }\n        return path\n      },\n      onRuntimeInitialized: () => {\n        console.log('âœ… WebAssembly runtime initialized')\n      }\n    })\n\n    wasmModule = {\n      EPCalculator: module.EPCalculator\n    }\n\n    console.log('ðŸš€ WebAssembly module loaded successfully')\n\n  } catch (error) {\n    loadError = error instanceof Error ? error.message : 'Unknown WebAssembly loading error'\n    console.error('âŒ Failed to load WebAssembly module:', loadError)\n    throw error\n  } finally {\n    isLoading = false\n  }\n}\n\n// Check if WebAssembly is available\nexport function isWasmAvailable(): boolean {\n  return wasmModule !== null\n}\n\n// Get WebAssembly loading status\nexport function getWasmStatus(): {\n  isLoaded: boolean\n  isLoading: boolean\n  error: string | null\n} {\n  return {\n    isLoaded: wasmModule !== null,\n    isLoading,\n    error: loadError\n  }\n}\n\n// Single computation using WebAssembly\nexport function computeWasm(params: ComputationParameters): WasmComputationResult {\n  if (!wasmModule) {\n    throw new Error('WebAssembly module not loaded')\n  }\n\n  try {\n    const result = wasmModule.EPCalculator.compute(params)\n    return result\n  } catch (error) {\n    console.error('WebAssembly computation error:', error)\n    return {\n      error_probability: 0,\n      error_exponent: 0,\n      optimal_rho: 0,\n      success: false,\n      error_message: error instanceof Error ? error.message : 'Computation failed'\n    }\n  }\n}\n\n// Batch computation using WebAssembly\nexport function computeBatchWasm(paramsList: ComputationParameters[]): WasmComputationResult[] {\n  if (!wasmModule) {\n    throw new Error('WebAssembly module not loaded')\n  }\n\n  try {\n    const results = wasmModule.EPCalculator.computeBatch(paramsList)\n    return results\n  } catch (error) {\n    console.error('WebAssembly batch computation error:', error)\n    // Return error results for all computations\n    return paramsList.map(() => ({\n      error_probability: 0,\n      error_exponent: 0,\n      optimal_rho: 0,\n      success: false,\n      error_message: error instanceof Error ? error.message : 'Batch computation failed'\n    }))\n  }\n}\n\n// Fallback function to check computation validity\nexport function validateComputationResult(result: WasmComputationResult): boolean {\n  if (!result.success) {\n    return false\n  }\n\n  // Check for valid numerical results\n  const { error_probability, error_exponent, optimal_rho } = result\n\n  return (\n    !isNaN(error_probability) && isFinite(error_probability) && error_probability >= 0 &&\n    !isNaN(error_exponent) && isFinite(error_exponent) && error_exponent >= 0 &&\n    !isNaN(optimal_rho) && isFinite(optimal_rho) && optimal_rho >= 0 && optimal_rho <= 1\n  )\n}\n\n// Performance benchmarking\nexport async function benchmarkWasm(iterations = 100): Promise<{\n  wasmAverage: number\n  wasmMin: number\n  wasmMax: number\n  memoryUsage: number\n}> {\n  if (!wasmModule) {\n    throw new Error('WebAssembly module not loaded')\n  }\n\n  const testParams: ComputationParameters = {\n    M: 4,\n    typeModulation: 'PAM',\n    SNR: 5.0,\n    R: 0.5,\n    N: 20,\n    n: 128,\n    threshold: 1e-6\n  }\n\n  const times: number[] = []\n  \n  // Warmup\n  for (let i = 0; i < 10; i++) {\n    computeWasm(testParams)\n  }\n\n  // Benchmark\n  for (let i = 0; i < iterations; i++) {\n    const start = performance.now()\n    computeWasm(testParams)\n    const end = performance.now()\n    times.push(end - start)\n  }\n\n  const wasmAverage = times.reduce((a, b) => a + b, 0) / times.length\n  const wasmMin = Math.min(...times)\n  const wasmMax = Math.max(...times)\n\n  // Memory usage (if available)\n  let memoryUsage = 0\n  if ('memory' in performance && 'usedJSHeapSize' in (performance as any).memory) {\n    memoryUsage = (performance as any).memory.usedJSHeapSize\n  }\n\n  return {\n    wasmAverage,\n    wasmMin,\n    wasmMax,\n    memoryUsage\n  }\n}\n\n// Memory management\nexport function cleanupWasm(): void {\n  if (wasmModule) {\n    console.log('ðŸ§¹ Cleaning up WebAssembly module')\n    wasmModule = null\n  }\n}\n\n// Error handling wrapper\nexport function withWasmErrorHandling<T>(\n  operation: () => T,\n  fallback: () => T\n): T {\n  try {\n    if (!wasmModule) {\n      console.warn('WebAssembly not available, using fallback')\n      return fallback()\n    }\n    return operation()\n  } catch (error) {\n    console.error('WebAssembly operation failed, using fallback:', error)\n    return fallback()\n  }\n}\n\n// Feature detection\nexport function getWasmCapabilities(): {\n  supported: boolean\n  threads: boolean\n  simd: boolean\n  bulkMemory: boolean\n  memory64: boolean\n} {\n  const capabilities = {\n    supported: typeof WebAssembly !== 'undefined',\n    threads: false,\n    simd: false,\n    bulkMemory: false,\n    memory64: false\n  }\n\n  if (capabilities.supported) {\n    try {\n      // Check for WebAssembly features\n      capabilities.simd = WebAssembly.validate(new Uint8Array([\n        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,\n        0x01, 0x05, 0x01, 0x60, 0x00, 0x01, 0x7b, 0x03,\n        0x02, 0x01, 0x00, 0x0a, 0x0a, 0x01, 0x08, 0x00,\n        0xfd, 0x0f, 0xfd, 0x62, 0x0b\n      ]))\n\n      capabilities.threads = typeof SharedArrayBuffer !== 'undefined'\n      capabilities.bulkMemory = WebAssembly.validate(new Uint8Array([\n        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00,\n        0x01, 0x04, 0x01, 0x60, 0x00, 0x00, 0x03, 0x02,\n        0x01, 0x00, 0x0a, 0x06, 0x01, 0x04, 0x00, 0xfc,\n        0x08, 0x0b\n      ]))\n    } catch {\n      // Feature detection failed, keep defaults\n    }\n  }\n\n  return capabilities\n}\n\n// Development helpers\nexport function getWasmDebugInfo(): {\n  moduleLoaded: boolean\n  loadTime: number\n  capabilities: ReturnType<typeof getWasmCapabilities>\n  status: ReturnType<typeof getWasmStatus>\n} {\n  const loadTime = wasmModule ? performance.now() : 0\n\n  return {\n    moduleLoaded: wasmModule !== null,\n    loadTime,\n    capabilities: getWasmCapabilities(),\n    status: getWasmStatus()\n  }\n}"