// Data parser for importing plot data from files

import {EPCalculatorJS} from "../../services/wasm-fallback.js";

/**
 * Parse parameters from EPCalculator-generated filename
 * @param {string} filename - e.g., "ErrorExponent_vs_n_QAM_M=16_SNR=10dB_R=0.5_14-23-45.csv"
 * @returns {object} - e.g., {typeModulation: "QAM", M: 16, SNR: 10, SNRUnit: "dB", R: 0.5}
 */
export function parseFilenameParams(filename) {
  // TODO(human): Implement filename parameter extraction
  //
  // Instructions:
  // 1. Remove file extension (.csv, .json)
  // 2. Split by underscore _
  // 3. Skip: yVar, "vs", xVar, timestamp (format: HH-MM-SS)
  // 4. For each remaining part:
  //    - If contains "=", extract key=value
  //    - Handle units: SNR=10dB → {SNR: 10, SNRUnit: "dB"}
  //    - Convert to numbers where possible
  //    - Map standalone values: QAM → typeModulation, Uniform → distribution, etc.
  //
  // Test cases:
  // "BER_vs_SNR_M=16_QAM_14-23-45.csv" → {M: 16, typeModulation: "QAM"}
  // "Pe_vs_n_SNR=10dB_R=0.5_14-23-45.csv" → {SNR: 10, SNRUnit: "dB", R: 0.5}
  // "Rho_vs_beta_Uniform_14-23-45.csv" → {distribution: "uniform"}
    const params = {};

    // TODO: HERE IMPLEMENT THE PARSING
    const name_no_ext = filename.replace(/\.(csv|json)$/,'');
    const parts = name_no_ext.split('_');
    for(let i = 3 /* Skip yVar, "vs", xVar */; i < parts.length; i++){
      const part = parts[i];

      // Skip timestamp
      if (part.match(/^\d{2}-\d{2}-\d{2}$/)) continue;

      if(part.includes('=')){ // variables with numbers (units)
        let [key,val] = part.split('=');
        if(key === 'β' || key === 'beta') {
          key = 'shaping_param';
        }
        params[key] = parseFloat(val);
        if(key === 'SNR'){
          if(val.includes('dB') || val.includes('DB') || val.includes('db')){
            params[key+'Unit'] = 'dB';
          }
          else{
            params[key+'Unit'] = 'linear';
          }
        }
      }
      else{ // variables with no units of the variable itself
        if(part.includes('-')){ // mod and constellation pair
          const [M, constellation] = part.split('-');
          params.typeModulation = constellation;
          params.M = Number(M);
        }
        else{
          switch(part) {
            case 'Uniform':
              params.distribution = 'uniform';
              break;
            case 'MB':
              params.distribution = 'maxwell-boltzmann';
              break;
            case 'PAM':
            case 'PSK':
            case 'QAM':
              params.typeModulation = part;
              break;
          }
        }

      }

    }
  return params;
}

/**
 * Detect if a file was generated by EPCalculator
 * @param {string} content - File content (CSV text or JSON object)
 * @param {string} type - File type: 'csv' or 'json'
 * @returns {boolean} - True if file was generated by EPCalculator
 */
export function detectEPCalculatorFile(content, type) {
  if (type === 'csv') {
    // Check for marker comment in first line
    const firstLine = content.split('\n')[0];
    return firstLine.includes('# EPCalculator v2.0');
  } else if (type === 'json') {
    // Check for generator field in JSON
    try {
      const data = typeof content === 'string' ? JSON.parse(content) : content;
      return data.generator === 'EPCalculator v2' || data.generator === 'EPCalculator v2.0';
    } catch (e) {
      return false;
    }
  }
  return false;
}

/**
 * Parse CSV data with x,y columns
 * Supports formats:
 * - With headers: x,y\n0,0.001\n1,0.005
 * - Without headers: 0,0.001\n1,0.005
 * - Comments: lines starting with #
 */
export function parseCSV(text) {
  const lines = text.split('\n').filter(line => {
    const trimmed = line.trim();
    return trimmed.length > 0 && !trimmed.startsWith('#');
  });

  if (lines.length === 0) {
    throw new Error('CSV file is empty');
  }

  let dataLines = lines;
  let xLabel = 'X';
  let yLabel = 'Y';

  // Check if first line is a header (contains non-numeric values)
  const firstLine = lines[0].split(',').map(s => s.trim());
  const firstIsHeader = firstLine.some(val => isNaN(parseFloat(val)));

  if (firstIsHeader) {
    xLabel = firstLine[0] || 'X';
    yLabel = firstLine[1] || 'Y';
    dataLines = lines.slice(1);
  }

  const xValues = [];
  const yValues = [];

  for (let i = 0; i < dataLines.length; i++) {
    const line = dataLines[i].trim();
    if (!line) continue;

    const parts = line.split(',').map(s => s.trim());

    if (parts.length < 2) {
      throw new Error(`Line ${i + 1}: Expected at least 2 columns, got ${parts.length}`);
    }

    const x = parseFloat(parts[0]);
    const y = parseFloat(parts[1]);

    if (isNaN(x) || isNaN(y)) {
      throw new Error(`Line ${i + 1}: Invalid numeric values (x=${parts[0]}, y=${parts[1]})`);
    }

    if (!isFinite(x) || !isFinite(y)) {
      throw new Error(`Line ${i + 1}: Values must be finite (no Infinity or NaN)`);
    }

    xValues.push(x);
    yValues.push(y);
  }

  if (xValues.length === 0) {
    throw new Error('No valid data points found in CSV');
  }

  return {
    x: xValues,
    y: yValues,
    xLabel,
    yLabel,
    pointCount: xValues.length
  };
}

/**
 * Parse JSON data
 * Supports formats:
 * - Simple: {x: [...], y: [...]}
 * - With metadata: {x: [...], y: [...], xLabel: "...", yLabel: "..."}
 * - With data wrapper: {data: {x: [...], y: [...]}, metadata: {...}}
 */
export function parseJSON(text) {
  let data;

  try {
    data = JSON.parse(text);
  } catch (e) {
    throw new Error(`Invalid JSON format: ${e.message}`);
  }

  // Handle nested data structure
  if (data.data && typeof data.data === 'object') {
    const metadata = data.metadata || {};
    return parseJSONData(data.data, metadata);
  }

  return parseJSONData(data, {});
}

function parseJSONData(data, metadata) {
  if (!data.x || !data.y) {
    throw new Error('JSON must contain "x" and "y" arrays');
  }

  if (!Array.isArray(data.x) || !Array.isArray(data.y)) {
    throw new Error('"x" and "y" must be arrays');
  }

  if (data.x.length !== data.y.length) {
    throw new Error(`Array length mismatch: x has ${data.x.length} elements, y has ${data.y.length} elements`);
  }

  if (data.x.length === 0) {
    throw new Error('Data arrays are empty');
  }

  // Validate all values are numeric and finite
  for (let i = 0; i < data.x.length; i++) {
    const x = data.x[i];
    const y = data.y[i];

    if (typeof x !== 'number' || typeof y !== 'number') {
      throw new Error(`Point ${i}: Values must be numbers (x=${typeof x}, y=${typeof y})`);
    }

    if (isNaN(x) || isNaN(y)) {
      throw new Error(`Point ${i}: Invalid numeric values`);
    }

    if (!isFinite(x) || !isFinite(y)) {
      throw new Error(`Point ${i}: Values must be finite (no Infinity or NaN)`);
    }
  }

  return {
    x: data.x,
    y: data.y,
    xLabel: metadata.xLabel || data.xLabel || 'X',
    yLabel: metadata.yLabel || data.yLabel || 'Y',
    title: metadata.title || data.title || null,
    pointCount: data.x.length
  };
}

/**
 * Parse file based on extension and content
 * Detects and handles both single-series and multi-series formats
 */
export function parseDataFile(filename, content) {
  const ext = filename.split('.').pop().toLowerCase();

  // Validate file size (5MB limit)
  const maxSize = 5 * 1024 * 1024;
  if (content.length > maxSize) {
    throw new Error(`File too large (${(content.length / 1024 / 1024).toFixed(1)}MB). Maximum size is 5MB`);
  }

  let result;

  try {
    if (ext === 'json') {
      // Try multi-series JSON first, fallback to single-series
      const data = JSON.parse(content);
      const multiSeriesResult = parseJSONMultiSeries(data);

      if (multiSeriesResult) {
        result = multiSeriesResult;
      } else {
        result = parseJSON(content);
      }
    } else if (ext === 'csv' || ext === 'txt') {
      // Try multi-column CSV first, fallback to single-series
      const multiSeriesResult = parseCSVMultiSeries(content);

      if (multiSeriesResult) {
        result = multiSeriesResult;
      } else {
        result = parseCSV(content);
      }
    } else {
      // Try to detect format by content
      const trimmed = content.trim();
      if (trimmed.startsWith('{') || trimmed.startsWith('[')) {
        const data = JSON.parse(content);
        const multiSeriesResult = parseJSONMultiSeries(data);
        result = multiSeriesResult || parseJSON(content);
      } else {
        const multiSeriesResult = parseCSVMultiSeries(content);
        result = multiSeriesResult || parseCSV(content);
      }
    }
  } catch (e) {
    throw new Error(`Failed to parse ${filename}: ${e.message}`);
  }

  // Validate data point count
  const maxPoints = 10000;
  const pointCount = result.isMultiSeries ? result.totalPoints : result.pointCount;
  if (pointCount > maxPoints) {
    throw new Error(`Too many data points (${pointCount}). Maximum is ${maxPoints}`);
  }

  // Add filename as fallback title
  if (!result.title && !result.isMultiSeries) {
    result.title = filename.replace(/\.(csv|json|txt)$/i, '');
  }

  return result;
}

/**
 * Read file as text
 */
export function readFileAsText(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();

    reader.onload = (e) => {
      resolve(e.target.result);
    };

    reader.onerror = () => {
      reject(new Error('Failed to read file'));
    };

    reader.readAsText(file);
  });
}

/**
 * Detect variable type from axis label
 * Maps common axis labels to known variable types
 */
export function detectVariableType(label) {
  const normalized = label.toLowerCase().trim();

  // SNR detection (various formats)
  if (normalized.includes('snr') || normalized.includes('signal') && normalized.includes('noise')) {
    return {
      varType: 'SNR',
      detectedUnit: normalized.includes('db') ? 'dB' : 'linear'
    };
  }

  // Code length
  if (normalized.includes('code length') || normalized === 'n' || normalized.includes('block length')) {
    return { varType: 'n', detectedUnit: null };
  }

  // Rate
  if (normalized.includes('rate') || normalized === 'r' || normalized.includes('coding rate')) {
    return { varType: 'R', detectedUnit: null };
  }

  // Modulation size
  if (normalized.includes('modulation size') || normalized === 'm' || normalized.includes('constellation size')) {
    return { varType: 'M', detectedUnit: null };
  }

  // Quadrature points
  if (normalized.includes('quadrature') || normalized === 'n' && normalized.includes('gauss')) {
    return { varType: 'N', detectedUnit: null };
  }

  // Error probability
  if (normalized.includes('error prob') || normalized.includes('probability of error') || normalized === 'pe') {
    return { varType: 'error_probability', detectedUnit: null };
  }

  // Error exponent
  if (normalized.includes('error exponent') || normalized.includes('exponent') && normalized.includes('error')) {
    return { varType: 'error_exponent', detectedUnit: null };
  }

  // Optimal rho
  if (normalized.includes('rho') || normalized === 'ρ' || normalized.includes('optimal')) {
    return { varType: 'rho', detectedUnit: null };
  }

  // Shaping parameter / beta
  if (normalized.includes('beta') || normalized === 'β' || normalized.includes('shaping')) {
    return { varType: 'shaping_param', detectedUnit: null };
  }

  // Unknown - use generic
  return { varType: null, detectedUnit: null };
}

/**
 * Parse multi-column CSV (wide format)
 * Format: X, Series1, Series2, Series3, ...
 * Returns array of series data
 */
export function parseCSVMultiSeries(text) {
  const lines = text.split('\n').filter(line => {
    const trimmed = line.trim();
    return trimmed.length > 0 && !trimmed.startsWith('#');
  });

  if (lines.length === 0) {
    throw new Error('CSV file is empty');
  }

  // Parse header
  const headers = lines[0].split(',').map(s => s.trim());

  if (headers.length < 3) {
    // Less than 3 columns - not multi-series, use regular parser
    return null;
  }

  const xLabel = headers[0];
  const seriesLabels = headers.slice(1); // All columns after first

  // Parse data lines
  const dataLines = lines.slice(1);
  const xValues = [];
  const seriesValues = seriesLabels.map(() => []); // Array of arrays

  for (let i = 0; i < dataLines.length; i++) {
    const line = dataLines[i].trim();
    if (!line) continue;

    const parts = line.split(',').map(s => s.trim());

    if (parts.length < headers.length) {
      throw new Error(`Line ${i + 2}: Expected ${headers.length} columns, got ${parts.length}`);
    }

    const x = parseFloat(parts[0]);
    if (isNaN(x) || !isFinite(x)) {
      throw new Error(`Line ${i + 2}: Invalid X value (${parts[0]})`);
    }

    xValues.push(x);

    // Parse each series column
    for (let j = 1; j < parts.length; j++) {
      const y = parts[j].trim() === '' ? null : parseFloat(parts[j]);

      if (y !== null && (isNaN(y) || !isFinite(y))) {
        throw new Error(`Line ${i + 2}, Column ${j + 1}: Invalid numeric value (${parts[j]})`);
      }

      seriesValues[j - 1].push(y);
    }
  }

  if (xValues.length === 0) {
    throw new Error('No valid data points found in CSV');
  }

  // Build series array
  const series = seriesLabels.map((label, i) => {
    // Filter out null values (empty cells)
    const validPoints = [];
    for (let j = 0; j < xValues.length; j++) {
      if (seriesValues[i][j] !== null) {
        validPoints.push({ x: xValues[j], y: seriesValues[i][j] });
      }
    }

    return {
      x: validPoints.map(p => p.x),
      y: validPoints.map(p => p.y),
      yLabel: label,
      pointCount: validPoints.length
    };
  });

  return {
    xLabel,
    series,
    isMultiSeries: true,
    totalPoints: xValues.length
  };
}

/**
 * Parse stacked-section CSV format (EPCalculator v2.0)
 * Format:
 *   # EPCalculator v2.0
 *   X_Label,Y_Label
 *   # [Series1_Params]
 *   x1,y1
 *   x2,y2
 *
 *   # [Series2_Params]
 *   x1,y1
 *   ...
 *
 * @param {string} text - CSV content
 * @returns {object} - {isMultiSeries: true, isProgramGenerated: true, xLabel, yLabel, series: [...]}
 */
/**
 * Parse EPCalculator-generated stacked CSV
 * @private Helper function for parseStackedCSV
 */
function parseEPCalculatorStacked(sections, headerLines) {
  const out = {
    series: [],
    isProgramGenerated: true,
    isMultiSeries: false,
    totalPoints: 0
  };

  // Extract global headers from first section
  [out.xLabel, out.yLabel] = headerLines[1].split(",").map(s => s.trim());

  let seriescounter = -1;

  // Parse each data section
  for(let i = 1; i < sections.length; i++){
    const lines = sections[i].split('\n');

    for(let j = 0; j < lines.length; j++){
      if(lines[j].trim()){
        if(lines[j].includes("#")){
          // New series header: "# [M=16, R=0.5]"
          seriescounter += 1;
          out.series[seriescounter] = {
            x: [],
            y: [],
            yLabel: "",
            uniqueParams: {},
            pointCount: 0
          };

          // Extract label
          out.series[seriescounter].yLabel = lines[j].replace("#","").replace("[","").replace("]","").trim();

          // Parse unique parameters
          const matches = lines[j].match(/[A-Za-z]=[\d.e-]+/g) || [];
          matches.forEach(match => {
            const [key,val] = match.split('=');
            out.series[seriescounter].uniqueParams[key] = parseFloat(val);
          });
        }
        else{
          // Data row
          const [x,y] = lines[j].split(",");
          out.series[seriescounter].x.push(parseFloat(x));
          out.series[seriescounter].y.push(parseFloat(y));
          out.series[seriescounter].pointCount += 1;
          out.totalPoints += 1;
        }
      }
    }
  }
  if(seriescounter > 1) out.isMultiSeries = true;

  return out;
}

function isAllNumbers(text){
  return /^[\d., ]+$/.test(text);
}


/**
 * Parse external stacked CSV (from Excel, MATLAB, Python, etc.)
 * @private Helper function for parseStackedCSV
 */
function parseExternalStacked(text) {
  // TODO(human): Implement external stacked CSV parser
  //
  // Handle formats from:
  // - Excel/Google Sheets (plain text headers, no comment chars)
  // - MATLAB (% comments)
  // - Python/Pandas (# comments, may repeat headers)
  //
  // Algorithm:
  // 1. Loop through sections
  // 2. For each section:
  //    - Detect if first line is comment (# or %) or plain text
  //    - Extract series label from first line
  //    - Skip header rows if present (check if line has letters vs numbers)
  //    - Parse numeric data rows (x,y pairs)
  // 3. Try to detect xLabel/yLabel from first section if it has headers
  // 4. Build series array
  //
  // Return structure same as EPCalculator format, but isProgramGenerated: false
  //
  // Test cases:
  // - Excel: "X,Y\n\nSeries 1\n1,0.5\n2,0.4\n\nSeries 2\n1,0.6\n2,0.5"
  // - MATLAB: "% Code length, Error\n\n% M=16\n100,0.45\n\n% M=32\n100,0.42"
  // - Python: "# First dataset\n100,0.45\n200,0.38\n\n# Second\n100,0.42"
  const out = {
    series: [],
    isProgramGenerated: false,
    isMultiSeries: false,
    totalPoints: 0,
    xLabel: "X",
    yLabel: "Y"
  };
  const lines = text.split('\n');
  let xylabelsfound = false;
  let seriescounter = -1;
  for(let i = 0; i < lines.length; i++){
    const line = lines[i].trim();
    if(line){ // if we don't have a blank line
      if(!xylabelsfound){
        if(line.includes(',')){ // check if its the xvar and yvar titles
          [out.xLabel, out.yLabel] = line.split(",").map(s=>s.trim());
          xylabelsfound = true;
          continue;
        }
      }
      if(!isAllNumbers(line.trim())){ // header or legend title
        seriescounter++;
        out.series[seriescounter] = {
          x: [],
          y: [],
          yLabel: line.replace(/^[#%]\s*/,'').trim(), // we store the legend title without the aux symbols at the start
          uniqueParams: {},
          pointCount: 0
        };

        const cleanLine = line.replace(/^[#%]\s*/,'').trim();
        cleanLine.split(',').forEach(pair => {if(pair.includes("=")){const [k, v] = pair.split("="); out.series[seriescounter].uniqueParams[k.trim()] = parseFloat(v);}});

        xylabelsfound = true; // no need to check anymore, they were not included
      }
      else{ // we found data points values!
        const xy = line.split(",");
        out.series[seriescounter].x.push(parseFloat(xy[0]));
        out.series[seriescounter].y.push(parseFloat(xy[1]));
        out.series[seriescounter].pointCount += 1;
        out.totalPoints += 1;
      }
    }
  }
  if(seriescounter+1 > 1) out.isMultiSeries = true;

  return out;
}

/**
 * Parse stacked-section CSV format
 * Routes to appropriate parser based on format detection
 */
export function parseStackedCSV(text) {
  const sections = text.split(/\n\n+/);

  if (sections.length < 2) {
    return null;  // Not stacked format
  }

  const headerLines = sections[0].split('\n');

  // Check if EPCalculator-generated (has marker)
  if(headerLines[0].trim() === "# EPCalculator v2.0"){
    return parseEPCalculatorStacked(sections, headerLines);
  }

  // Try parsing as external stacked format
  return parseExternalStacked(text);
}

/**
 * Parse multi-series JSON (new v2.0 format)
 * Format: { version: "2.0", isMultiSeries: true, series: [...] }
 */
export function parseJSONMultiSeries(data) {
  // Check if this is the new multi-series format
  if (!data.isMultiSeries || !data.series || !Array.isArray(data.series)) {
    return null; // Not multi-series format
  }

  if (data.series.length === 0) {
    throw new Error('Multi-series JSON has no series data');
  }

  const xLabel = data.plot?.xLabel || 'X';
  const yLabel = data.plot?.yLabel || 'Y';

  // Parse each series
  const series = data.series.map((seriesData, i) => {
    const xArr = seriesData.data?.x;
    const yArr = seriesData.data?.y;

    if (!Array.isArray(xArr) || !Array.isArray(yArr)) {
      throw new Error(`Series ${i + 1}: Missing or invalid x/y arrays`);
    }

    if (xArr.length !== yArr.length) {
      throw new Error(`Series ${i + 1}: Array length mismatch (x: ${xArr.length}, y: ${yArr.length})`);
    }

    // Validate all values
    for (let j = 0; j < xArr.length; j++) {
      if (typeof xArr[j] !== 'number' || typeof yArr[j] !== 'number') {
        throw new Error(`Series ${i + 1}, Point ${j}: Values must be numbers`);
      }
      if (!isFinite(xArr[j]) || !isFinite(yArr[j])) {
        throw new Error(`Series ${i + 1}, Point ${j}: Values must be finite`);
      }
    }

    return {
      x: xArr,
      y: yArr,
      yLabel: seriesData.name || `Series ${i + 1}`,
      pointCount: xArr.length,
      // Preserve metadata for perfect round-trip
      metadata: seriesData.metadata || {},
      simulationParams: seriesData.simulationParams || {},
      plotParams: seriesData.plotParams || {}
    };
  });

  return {
    xLabel,
    yLabel,
    series,
    isMultiSeries: true,
    globalParams: data.globalParams || [],
    totalPoints: series.reduce((sum, s) => sum + s.pointCount, 0)
  };
}
