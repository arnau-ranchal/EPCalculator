import type {\n  ComputationParameters,\n  ComputationResult,\n  PlotParameters,\n  PlotResult,\n  ContourParameters,\n  ContourResult,\n  ApiError\n} from '../types'\nimport { sessionStore } from '../stores/session'\nimport { get } from 'svelte/store'\n\n// API configuration\nconst API_BASE = '/api'\nconst REQUEST_TIMEOUT = 30000 // 30 seconds\n\n// Request headers\nfunction getHeaders(): HeadersInit {\n  const session = get(sessionStore)\n  return {\n    'Content-Type': 'application/json',\n    'X-Session-ID': session.sessionId,\n    'Accept': 'application/json'\n  }\n}\n\n// Generic API request wrapper with error handling\nasync function apiRequest<T>(\n  endpoint: string,\n  options: RequestInit = {}\n): Promise<T> {\n  const controller = new AbortController()\n  const timeoutId = setTimeout(() => controller.abort(), REQUEST_TIMEOUT)\n\n  try {\n    const response = await fetch(`${API_BASE}${endpoint}`, {\n      ...options,\n      headers: {\n        ...getHeaders(),\n        ...options.headers\n      },\n      signal: controller.signal\n    })\n\n    clearTimeout(timeoutId)\n\n    // Update session activity\n    sessionStore.updateActivity()\n\n    if (!response.ok) {\n      const errorData: ApiError = await response.json().catch(() => ({\n        error: 'Network Error',\n        message: `HTTP ${response.status}: ${response.statusText}`,\n        statusCode: response.status\n      }))\n      throw new Error(errorData.message || `API request failed with status ${response.status}`)\n    }\n\n    return await response.json()\n  } catch (error) {\n    clearTimeout(timeoutId)\n    \n    if (error instanceof Error && error.name === 'AbortError') {\n      throw new Error('Request timeout - computation may be too complex')\n    }\n    \n    throw error\n  }\n}\n\n// Single computation\nexport async function computeSingle(\n  parameters: ComputationParameters\n): Promise<ComputationResult> {\n  const result = await apiRequest<ComputationResult>('/compute', {\n    method: 'POST',\n    body: JSON.stringify(parameters)\n  })\n\n  // Update computation count\n  sessionStore.incrementComputations()\n\n  return result\n}\n\n// Batch computation\nexport async function computeBatch(\n  parameters: ComputationParameters[]\n): Promise<{ results: ComputationResult[]; total_computation_time_ms: number }> {\n  const result = await apiRequest<{\n    results: ComputationResult[]\n    total_computation_time_ms: number\n  }>('/compute/batch', {\n    method: 'POST',\n    body: JSON.stringify({ parameters })\n  })\n\n  // Update computation count\n  for (let i = 0; i < parameters.length; i++) {\n    sessionStore.incrementComputations()\n  }\n\n  return result\n}\n\n// Plot generation\nexport async function generatePlot(\n  parameters: PlotParameters\n): Promise<PlotResult> {\n  return await apiRequest<PlotResult>('/plot', {\n    method: 'POST',\n    body: JSON.stringify(parameters)\n  })\n}\n\n// Contour plot generation\nexport async function generateContour(\n  parameters: ContourParameters\n): Promise<ContourResult> {\n  return await apiRequest<ContourResult>('/contour', {\n    method: 'POST',\n    body: JSON.stringify(parameters)\n  })\n}\n\n// Legacy endpoint compatibility\nexport async function computeLegacy(\n  M: number,\n  typeM: string,\n  SNR: number,\n  R: number,\n  N: number,\n  n: number,\n  th: number\n): Promise<{\n  'Probabilidad de error': number\n  'error_exponent': number\n  'rho Ã³ptima': number\n}> {\n  const params = new URLSearchParams({\n    M: M.toString(),\n    typeM,\n    SNR: SNR.toString(),\n    R: R.toString(),\n    N: N.toString(),\n    n: n.toString(),\n    th: th.toString()\n  })\n\n  return await apiRequest(`/exponents?${params.toString()}`, {\n    method: 'GET'\n  })\n}\n\n// Health check\nexport async function healthCheck(): Promise<{\n  status: string\n  timestamp: string\n  version: string\n  uptime: number\n  services: {\n    database: boolean\n    computation: boolean\n  }\n  university: {\n    name: string\n    activeUsers: number\n    maxUsers: number\n  }\n  resources: {\n    memory: {\n      used: number\n      total: number\n      percentage: number\n    }\n    activeComputations: number\n  }\n}> {\n  return await apiRequest('/health')\n}\n\n// Analytics\nexport async function getAnalytics(): Promise<{\n  computations: {\n    total: number\n    today: number\n    averageTime: number\n    active: number\n  }\n  users: {\n    total: number\n    active: number\n    activeLastHour: number\n  }\n  performance: {\n    databaseSize: number\n    memoryUsage: number\n    uptime: number\n  }\n}> {\n  return await apiRequest('/analytics')\n}\n\n// Get computation history\nexport async function getComputationHistory(\n  sessionId?: string,\n  limit = 50\n): Promise<Array<{\n  id: number\n  timestamp: string\n  parameters: string\n  results: string\n  computation_time_ms: number\n}>> {\n  const endpoint = sessionId \n    ? `/analytics/history/${sessionId}?limit=${limit}`\n    : `/analytics/history?limit=${limit}`\n  \n  return await apiRequest(endpoint)\n}\n\n// Retry mechanism for failed requests\nexport async function withRetry<T>(\n  operation: () => Promise<T>,\n  maxRetries = 3,\n  delay = 1000\n): Promise<T> {\n  let lastError: Error\n  \n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await operation()\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error('Unknown error')\n      \n      if (attempt === maxRetries) {\n        throw lastError\n      }\n      \n      // Exponential backoff\n      const waitTime = delay * Math.pow(2, attempt - 1)\n      await new Promise(resolve => setTimeout(resolve, waitTime))\n    }\n  }\n  \n  throw lastError!\n}\n\n// Connection status monitoring\nlet isOnline = navigator.onLine\nlet connectionListeners: ((online: boolean) => void)[] = []\n\nwindow.addEventListener('online', () => {\n  isOnline = true\n  connectionListeners.forEach(listener => listener(true))\n})\n\nwindow.addEventListener('offline', () => {\n  isOnline = false\n  connectionListeners.forEach(listener => listener(false))\n})\n\nexport function onConnectionChange(listener: (online: boolean) => void): () => void {\n  connectionListeners.push(listener)\n  \n  // Return unsubscribe function\n  return () => {\n    connectionListeners = connectionListeners.filter(l => l !== listener)\n  }\n}\n\nexport function isNetworkOnline(): boolean {\n  return isOnline\n}\n\n// Request queue for offline support\ninterface QueuedRequest {\n  id: string\n  endpoint: string\n  options: RequestInit\n  timestamp: number\n  resolve: (value: any) => void\n  reject: (error: Error) => void\n}\n\nlet requestQueue: QueuedRequest[] = []\n\nexport function queueRequest<T>(\n  endpoint: string,\n  options: RequestInit = {}\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    const request: QueuedRequest = {\n      id: Math.random().toString(36).substring(2),\n      endpoint,\n      options,\n      timestamp: Date.now(),\n      resolve,\n      reject\n    }\n    \n    requestQueue.push(request)\n    \n    // Try to process queue if online\n    if (isOnline) {\n      processRequestQueue()\n    }\n  })\n}\n\nasync function processRequestQueue(): Promise<void> {\n  if (!isOnline || requestQueue.length === 0) {\n    return\n  }\n  \n  const request = requestQueue.shift()!\n  \n  try {\n    const result = await apiRequest(request.endpoint, request.options)\n    request.resolve(result)\n  } catch (error) {\n    request.reject(error instanceof Error ? error : new Error('Unknown error'))\n  }\n  \n  // Process next request\n  if (requestQueue.length > 0) {\n    setTimeout(processRequestQueue, 100)\n  }\n}\n\n// Auto-process queue when coming back online\nonConnectionChange((online) => {\n  if (online) {\n    processRequestQueue()\n  }\n})\n\n// Clear old queued requests (older than 5 minutes)\nsetInterval(() => {\n  const fiveMinutesAgo = Date.now() - 5 * 60 * 1000\n  const originalLength = requestQueue.length\n  \n  requestQueue = requestQueue.filter(request => {\n    if (request.timestamp < fiveMinutesAgo) {\n      request.reject(new Error('Request expired'))\n      return false\n    }\n    return true\n  })\n  \n  if (requestQueue.length !== originalLength) {\n    console.log(`Cleared ${originalLength - requestQueue.length} expired requests from queue`)\n  }\n}, 60000) // Check every minute"